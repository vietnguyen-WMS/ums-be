BEGIN;

-- 1) Schema + extensions (public đang là default schema)
CREATE SCHEMA IF NOT EXISTS ums;

-- Case-insensitive text cho username
CREATE EXTENSION IF NOT EXISTS citext;

-- Bcrypt hashing (crypt/gen_salt)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 2) Bảng status_codes
CREATE TABLE IF NOT EXISTS ums.status_codes (
  id         SMALLSERIAL PRIMARY KEY,
  domain     TEXT        NOT NULL,   -- ví dụ: 'ums'
  code       TEXT        NOT NULL,   -- 'active','inactive','locked'
  name       TEXT        NOT NULL,
  is_active  BOOLEAN     NOT NULL DEFAULT TRUE,
  sort_order INT         NOT NULL DEFAULT 0,
  UNIQUE (domain, code)
);

-- 3) Helper function lấy id status theo (domain, code)
CREATE OR REPLACE FUNCTION ums.get_status_id(p_domain TEXT, p_code TEXT)
RETURNS SMALLINT
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_id SMALLINT;
BEGIN
  SELECT id::SMALLINT
    INTO v_id
  FROM ums.status_codes
  WHERE domain = p_domain
    AND code   = p_code
  LIMIT 1;

  IF v_id IS NULL THEN
    RAISE EXCEPTION 'status code not found for domain=%, code=%', p_domain, p_code;
  END IF;

  RETURN v_id;
END
$$;

-- 4) Bảng users
CREATE TABLE IF NOT EXISTS ums.users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  username citext NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,                         -- chỉ lưu HASH

  status_id SMALLINT NOT NULL
           DEFAULT ums.get_status_id('ums','active')
           REFERENCES ums.status_codes(id),

  failed_login_attempts INT NOT NULL DEFAULT 0 CHECK (failed_login_attempts >= 0),
  last_login_at TIMESTAMPTZ,
  last_password_change_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by BIGINT REFERENCES ums.users(id) ON DELETE SET NULL,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_by BIGINT REFERENCES ums.users(id) ON DELETE SET NULL,

  deleted_at TIMESTAMPTZ,

  CONSTRAINT username_not_blank CHECK (length(btrim(username::text)) > 0),
  CONSTRAINT pw_not_blank       CHECK (length(btrim(password_hash)) > 0)
);

-- Indexes hữu ích cho FK/tra cứu
CREATE INDEX IF NOT EXISTS idx_users_status_id  ON ums.users(status_id);
CREATE INDEX IF NOT EXISTS idx_users_created_by ON ums.users(created_by);
CREATE INDEX IF NOT EXISTS idx_users_updated_by ON ums.users(updated_by);

-- 5) Trigger tự cập nhật updated_at khi UPDATE
CREATE OR REPLACE FUNCTION ums.tg_set_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END
$$;

DROP TRIGGER IF EXISTS set_updated_at ON ums.users;
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON ums.users
FOR EACH ROW
EXECUTE FUNCTION ums.tg_set_updated_at();

-- 6) Seed các status codes tối thiểu
INSERT INTO ums.status_codes (domain, code, name, is_active, sort_order)
VALUES
  ('ums','active',   'Active',   TRUE, 1),
  ('ums','inactive', 'Inactive', TRUE, 2),
  ('ums','locked',   'Locked',   TRUE, 3)
ON CONFLICT (domain, code) DO UPDATE
SET name = EXCLUDED.name,
    is_active = EXCLUDED.is_active,
    sort_order = EXCLUDED.sort_order;

-- 7) Tạo user admin với mật khẩu 'admin@123' (bcrypt)
--    Lưu ý: cần extension pgcrypto để dùng crypt/gen_salt('bf')
INSERT INTO ums.users (username, password_hash, status_id, created_at, updated_at)
VALUES (
  'admin',
  crypt('admin@123', gen_salt('bf')),
  ums.get_status_id('ums','active'),
  NOW(),
  NOW()
)
ON CONFLICT (username) DO UPDATE
SET password_hash = EXCLUDED.password_hash,
    status_id     = EXCLUDED.status_id,
    updated_at    = NOW();

-- Set created_by / updated_by = chính nó nếu đang NULL
UPDATE ums.users u
SET created_by = u.id,
    updated_by = u.id
WHERE u.username = 'admin'
  AND (u.created_by IS NULL OR u.updated_by IS NULL);

COMMIT;
