BEGIN;

-- 1) Schema + extensions (public is default schema)
CREATE SCHEMA IF NOT EXISTS ums;

-- Case-insensitive text for username
CREATE EXTENSION IF NOT EXISTS citext;

-- Bcrypt hashing (crypt/gen_salt)
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 2) Table: status_codes
CREATE TABLE IF NOT EXISTS ums.status_codes (
  id         SMALLSERIAL PRIMARY KEY,
  domain     TEXT        NOT NULL,   -- e.g., 'ums'
  code       TEXT        NOT NULL,   -- 'active','inactive','locked'
  name       TEXT        NOT NULL,
  is_active  BOOLEAN     NOT NULL DEFAULT TRUE,
  sort_order INT         NOT NULL DEFAULT 0,
  UNIQUE (domain, code)
);

-- 3) Helper function: get status_id by (domain, code)
CREATE OR REPLACE FUNCTION ums.get_status_id(p_domain TEXT, p_code TEXT)
RETURNS SMALLINT
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_id SMALLINT;
BEGIN
  SELECT id::SMALLINT
    INTO v_id
  FROM ums.status_codes
  WHERE domain = p_domain
    AND code   = p_code
  LIMIT 1;

  IF v_id IS NULL THEN
    RAISE EXCEPTION 'status code not found for domain=%, code=%', p_domain, p_code;
  END IF;

  RETURN v_id;
END
$$;

-- 3.1) Table: roles (only one table for role control)
CREATE TABLE IF NOT EXISTS ums.user_roles (
  id   SMALLSERIAL PRIMARY KEY,
  code TEXT NOT NULL UNIQUE,  -- 'admin','supervisor','operator'
  name TEXT NOT NULL
);

-- 3.2) Helper function: get role_id by code
CREATE OR REPLACE FUNCTION ums.get_role_id(p_code TEXT)
RETURNS SMALLINT
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_id SMALLINT;
BEGIN
  SELECT id::SMALLINT
    INTO v_id
  FROM ums.user_roles
  WHERE code = p_code
  LIMIT 1;

  IF v_id IS NULL THEN
    RAISE EXCEPTION 'role not found for code=%', p_code;
  END IF;

  RETURN v_id;
END
$$;

-- 4) Table: users
--    Add role_id (FK â†’ user_roles), default = 'operator'
CREATE TABLE IF NOT EXISTS ums.users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  username citext NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,                         -- store only HASH

  status_id SMALLINT NOT NULL
           DEFAULT ums.get_status_id('ums','active')
           REFERENCES ums.status_codes(id),

  role_id SMALLINT NOT NULL
         DEFAULT ums.get_role_id('operator')
         REFERENCES ums.user_roles(id),

  failed_login_attempts INT NOT NULL DEFAULT 0 CHECK (failed_login_attempts >= 0),
  last_login_at TIMESTAMPTZ,
  last_password_change_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by BIGINT REFERENCES ums.users(id) ON DELETE SET NULL,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_by BIGINT REFERENCES ums.users(id) ON DELETE SET NULL,

  deleted_at TIMESTAMPTZ,

  CONSTRAINT username_not_blank CHECK (length(btrim(username::text)) > 0),
  CONSTRAINT pw_not_blank       CHECK (length(btrim(password_hash)) > 0)
);

-- Useful indexes for FK/lookups
CREATE INDEX IF NOT EXISTS idx_users_status_id  ON ums.users(status_id);
CREATE INDEX IF NOT EXISTS idx_users_role_id    ON ums.users(role_id);
CREATE INDEX IF NOT EXISTS idx_users_created_by ON ums.users(created_by);
CREATE INDEX IF NOT EXISTS idx_users_updated_by ON ums.users(updated_by);

-- 5) Trigger: auto-update updated_at on UPDATE
CREATE OR REPLACE FUNCTION ums.tg_set_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END
$$;

DROP TRIGGER IF EXISTS set_updated_at ON ums.users;
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON ums.users
FOR EACH ROW
EXECUTE FUNCTION ums.tg_set_updated_at();

-- 6) Seed minimal status codes
INSERT INTO ums.status_codes (domain, code, name, is_active, sort_order)
VALUES
  ('ums','active',   'Active',   TRUE, 1),
  ('ums','inactive', 'Inactive', TRUE, 2),
  ('ums','locked',   'Locked',   TRUE, 3)
ON CONFLICT (domain, code) DO UPDATE
SET name = EXCLUDED.name,
    is_active = EXCLUDED.is_active,
    sort_order = EXCLUDED.sort_order;

-- 6.1) Seed roles
INSERT INTO ums.user_roles (code, name) VALUES
  ('admin',      'Administrator'),
  ('supervisor', 'Supervisor'),
  ('operator',   'Operator')
ON CONFLICT (code) DO UPDATE
SET name = EXCLUDED.name;

-- 7) Seed/Upsert admin user with password 'admin@123' and role = 'admin'
INSERT INTO ums.users (username, password_hash, status_id, role_id, created_at, updated_at)
VALUES (
  'admin',
  crypt('admin@123', gen_salt('bf')),
  ums.get_status_id('ums','active'),
  ums.get_role_id('admin'),
  NOW(),
  NOW()
)
ON CONFLICT (username) DO UPDATE
SET password_hash = EXCLUDED.password_hash,
    status_id     = EXCLUDED.status_id,
    role_id       = EXCLUDED.role_id,
    updated_at    = NOW();

-- Set created_by / updated_by = itself if NULL
UPDATE ums.users u
SET created_by = u.id,
    updated_by = u.id
WHERE u.username = 'admin'
  AND (u.created_by IS NULL OR u.updated_by IS NULL);

COMMIT;
